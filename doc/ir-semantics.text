# The formal language

x        variables

l        labels

a        addresses

P ::= (l ↦ i)*          program

i ::=    instructions
| const x = e           constant variable
| mut x = e             mutable variable
| x <- e                assignment
| branch x l₁ l₂        conditional
| goto l                goto
| print x               print
| invalidate(e, l, x̄)   invalidate

x̄        list of variables

e ::=    (simple) expressions
| lit                   literals
| x                     variables
| primop(x, ...)        primitive operation (pure)

lit ::=  litterals
| nil
| true | false
| 0 | 1 | 2 | ...

v :=     values
| lit                   literals

(Note: heap adresses are not values)

# Natural operational semantics

E ::= (x ↦const v | x ↦var a)*  lexical environment
H ::= (l ↦ v)                   mutable heap

T ::= (lit)*                    output trace
Configuration: (T, H, E, P, l)

Lookup (partial) function, returns a v:
  (H,E)[x] :=
    v    if E ∋ (x ↦const v)
    H(l) if E ∋ (x ↦mut l)

Update (partial) function, returns a S:
  (H,E)[x ← v] :=
    H[E(x) ↦ v] if E ∋ (x ↦mut l)

Evaluation of simple expressions:

  eval H E x = (H,E)[x]
  eval H E lit = lit
  eval H E primop(x₁, ..., xₙ) = 〚primop〛((H,E)[x₁], ..., (H,E)[xₙ])

Reduction relation
  (T, H, E, P, l) -> ((T, (H,E)[x]), H, E, P, l + 1)
    when P(l) = print x

  (T, H, E, P, l) -> (T, H, E, P, l')
    where P(l) = branch x l₁ l₂
      and l' := if (H,E)[x] then l₁ else l₂

  (T, H, E, P, l) -> (T, H, (E, x ↦ v), P, l+1)
    when P(l) = (const x = e)
     and v := eval H E x

  (T, H, E, P, l) -> (T, (H, a ↦ v), (E, x ↦ a), P, l+1)
    when P(l) = (mut x = e)
     and v := eval H E e
     and a fresh

  (T, H, E, P, l) -> (T, (H,E)[x] := v, E, P, l+1)
    when P(l) = (x ← e)
     and v := eval H E x

  (T, H, E, P, l) -> (T, H, E, P, l+1)
    when P(l) = invalidate(e, l', x̄)
     and (eval H E e) is (true)

  (T, H, E, P, l) -> (T, H, E|x̄, P, l')
    when P(l) = invalidate(e, l', x̄)
     and (eval H E e) is not (true)
