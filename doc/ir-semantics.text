# The formal language

x        variables

l        labels
v        optimization version

a        addresses

C ::= (v ↦ P)*          compilation unit
P ::= (l ↦ i)*          program

i ::=    instructions
| const x = e               constant variable
| mut x = e                 mutable variable
| x <- e                    assignment
| branch x l₁ l₂            conditional
| goto l                    goto
| print x                   print
| osr(e, v, l, (x = ee)*)   osr : (can be used for osr-in and osr-out)

ee ::=   extended expression
| e
| ⊥

e ::=    (simple) expressions
| lit                   literals
| x                     variables
| primop(x, ...)        primitive operation (pure)

lit ::=  litterals
| nil
| true | false
| 0 | 1 | 2 | ...

v :=     values
| lit                   literals

(Note: heap adresses are not values)

# Natural operational semantics

E ::= (x ↦const v | x ↦var a | x ↦⊥)*  lexical environment
H ::= (l ↦ v)                          mutable heap

T ::= (lit)*                    output trace
Configuration: (T, H, E, C, P, l)

Lookup (partial) function, returns a v:
  (H,E)[x] :=
    v    if E ∋ (x ↦const v)
    H(l) if E ∋ (x ↦mut l)

Update (partial) function, returns a S:
  (H,E)[x ← v] :=
    H[E(x) ↦ v] if E ∋ (x ↦mut l)

Evaluation of simple expressions:

  eval H E x = (H,E)[x]
  eval H E lit = lit
  eval H E primop(x₁, ..., xₙ) = 〚primop〛((H,E)[x₁], ..., (H,E)[xₙ])

Reduction relation
  (T, H, E, C, P, l) -> ((T, (H,E)[x]), H, E, C, P, l + 1)
    when P(l) = print x

  (T, H, E, C, P, l) -> (T, H, E, C, P, l')
    where P(l) = branch x l₁ l₂
      and l' := if (H,E)[x] then l₁ else l₂

  (T, H, E, C, P, l) -> (T, H, (E, x ↦ v), C, P, l+1)
    when P(l) = (const x = e)
     and v := eval H E x

  (T, H, E, C, P, l) -> (T, (H, a ↦ v), (E, x ↦ a), C, P, l+1)
    when P(l) = (mut x = e)
     and v := eval H E e
     and a fresh

  (T, H, E, C, P, l) -> (T, (H,E)[x] := v, E, C, P, l+1)
    when P(l) = (x ← e)
     and v := eval H E x

  (T, H, E, C, P, l) -> (T, H, E, C, P, l+1)
    when P(l) = osr(e, _, _)
     and (eval H E e) is not (true)

  (T, H, E, C, P, l) -> (T, H, E', C, P', l')
    when P(l) = osr(e, v, l', (x = ee)*)
     and (eval H E e) is (true)
     and P' := C(v)
     and E' := (x ↦ ⊥ | (eval H E ee))*

# scoping rules

declares i =
  | mut x _         -> [x]
  | const x _       -> [x]
  | _               -> []

requires i =
  | mut x = e
  | const x = e
  | osr e, _        -> vars(e)
  | x <- e          -> x :: vars(e)
  | branch x _
  | print x         -> [x]
  | _               -> []


# Compilation unit has a valid scope if every program version
# has a valid scope. Program has a valid scope if every
# instruction has a valid scope

valid C =
  ∀ v ∈ C :
    valid_at_v C v  ∧  valid_osr C v

valid_at_v C v =
  ∀ l ∈ C(v) :
    valid_at_l C(v) l

# An instruction has a valid scope if every required variable
# is declared in the transitive closure of every predecessor.

valid_at_l P l =
  ∀ x ∈ requires P(l) :
    reach_decl P l x []

reach_decl P l x seen =
  ∀ l' ∈ pred P l \ seen :
    x ∈ declares P(l')  ∨
    (∃ l'' ∈ pred* P l' :
       x ∈ declares P(l'')
     ∧
     reach_decl P l' x (l' :: seen))

# Successors are either the targets of jumps or the
# next instruction in the stream (if it exists)

succ P l =
 | goto l'                                -> [l']
 | branch _ l' l''                        -> [l', l'']
 | when P = {..., l -> _, l' -> _, ...}   -> l'
 | _                                      -> []

pred P l =
  { l' ∈ P : succ P l' = l }

# Osr instructions create a valid environment if it
# contains all variables which are in scope at the osr
# entry point

valid_osr C v =
  ∀ osr(e, v', l', (x = ee)*) ∈ C(v) :
    valid_osr_at_v C v' l' x̄

valid_osr_at_v C v l_osr scope_osr =
  ∀ l ∈ succ* C(v) l_osr :
    valid_osr_at_l C(v) l l_osr scope_osr

valid_osr_at_l P l l_osr scope_osr =
  ∀ x ∈ requires P(l) :
    reach_decl_check_osr P l x l_osr scope_osr []

reach_decl_check_osr P l x l_osr scope_osr seen =
  ∀ l' ∈ pred P l \ seen :
    x ∈ declares P(l')  ∨
    (l' = l_osr ⇒ x ∈ scope_osr
     ∧
     reach_decl P l' x (l' :: seen))
